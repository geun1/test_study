# 운영체제 학습 노트

## 목차

-   [Chapter 1. Introduction](#chapter-1-introduction)
    -   [1. 운영체제의 기본 개념과 역할](#1-운영체제의-기본-개념과-역할)
    -   [2. 시스템 구성 요소](#2-시스템-구성-요소)
    -   [3. 클러스터 시스템 vs 멀티프로세서](#3-클러스터-시스템-vs-멀티프로세서)
    -   [4. OS/시스템/응용 프로그램 차이점](#4-os시스템응용-프로그램-차이점)
-   [Chapter 2. OS Structure](#chapter-2-os-structure)
    -   [1. 멀티프로그래밍 vs 멀티태스킹](#1-멀티프로그래밍-vs-멀티태스킹)
    -   [2. 시스템 콜(System Call)](#2-시스템-콜system-call)
    -   [3. 컴퓨터 구성 Review](#3-컴퓨터-구성-review)
    -   [4. 프로그램 실행시 수행되는 서브루틴](#4-프로그램-실행시-수행되는-서브루틴)

## Chapter 1. Introduction

운영체제의 기본 개념과 역할에 대해 학습함. OS는 유저와 하드웨어 사이의 중개자 역할을 하며, 하드웨어를 효율적으로 사용하고 유저 프로그램 실행을 지원하는 것을 목적으로 함을 이해함. 커널, 시스템 프로그램, 응용 프로그램의 차이를 학습하고, 부트 스트랩 프로그램, 인터럽트, 트랩/예외, 입출력 방식(Synchronous/Asynchronous I/O, DMA), 캐싱, 멀티프로세싱(Asymmetric, Symmetric), NUMA, 블레이드 서버, 클러스터형 시스템 등의 개념을 익힘.

### 1. 운영체제의 기본 개념과 역할

-   OS는 사용자와 하드웨어 사이의 중개자 역할
-   주로 항상 실행중인 프로그램인 kernel을 의미
-   자원 관리와 사용자 프로그램 실행, 효율적인 HW 사용 지원이 주요 목적

### 2. 시스템 구성 요소

-   **CPU**: 명령어 실행 하드웨어
-   **프로세서 (Processor)**: 하나 이상의 CPU 포함하는 물리적 칩
-   **코어 (Core)**: CPU 기본 계산 단위, 현대 시스템은 대부분 다중 코어(multicore) 형태
-   **다중 처리기 시스템(Multiprocessor)**: 여러 프로세서를 포함하여 성능 향상

### 3. 클러스터 시스템 vs 멀티프로세서

| 항목      | 클러스터 시스템                       | 멀티프로세서             |
| --------- | ------------------------------------- | ------------------------ |
| 구조      | 독립된 컴퓨터 시스템 간 네트워크 연결 | 하나의 시스템에 여러 CPU |
| 자원 공유 | 주로 스토리지(SAN)                    | 메모리 등 전체 자원 공유 |
| 목적      | 고가용성(failover, redundancy)        | 고성능 연산, 병렬 처리   |
| OS 관리   | 분산OS 관리                           | 단일OS가 전체CPU 관리    |

### 4. OS/시스템/응용 프로그램 차이점

-   **시스템 프로그램**: OS와 사용자 사이 기능 제공 (파일 탐색기, cmd)
-   **응용 프로그램**: 사용자 목적을 수행하는 앱 (브라우저, 워드)
-   컴파일러도 시스템 프로그램에 해당하지만, 분류는 관점에 따라 다름

## Chapter 2. OS Structure

멀티프로그래밍과 타임쉐어링, 가상 메모리, Dual-mode 운영, 타이머의 역할 등을 학습했으며, OS 구조 측면에서는 사용자 인터페이스, 시스템 콜과 시스템 프로그램의 개념, 그리고 모놀리식 구조, 계층적 구조, 마이크로커널 구조, LKM 방식 등 운영체제 설계 방법에 대해 공부함.

### 1. 멀티프로그래밍 vs 멀티태스킹

| 항목      | 멀티프로그래밍                   | 멀티태스킹                         |
| --------- | -------------------------------- | ---------------------------------- |
| 목적      | CPU 효율 향상                    | 사용자 반응성 향상                 |
| 처리 방식 | I/O 대기 시 다른 프로세스로 전환 | 짧은 시간 단위로 작업 전환         |
| 병렬성    | 없음(논리적 전환)                | 없음(시간 분할)                    |
| 기반 기술 | 초기OS 구조                      | 현대GUI 기반OS (Windows, macOS 등) |

### 2. 시스템 콜(System Call)

-   **정의**: 운영체제가 제공하는 서비스의 인터페이스로 C, C++같은 고수준 언어로 작성됨
-   직접적인 사용보다는 high-level API를 사용해 프로그램에서 접근
-   운영체제는 시스템 콜 번호를 사용해서 해당 시스템 콜을 식별
-   시스템 콜 인터페이스는 해당 번호로 인덱싱된 테이블을 관리하고, OS 커널에서 시스템 콜을 부른다

### 3. 컴퓨터 구성 Review
![image](https://github.com/user-attachments/assets/ad5c2b43-2659-4bb0-b26f-a77b70bb2716)

-   **Data path 흐름**

    1. PC가 가리키는 주소의 명령어를 메모리에서 읽어 IR로 이동
    2. IR 해독 → 오퍼랜드 위치 결정
    3. operand를 DR에 불러오고, ALU로 연산 수행
    4. 결과는 AC 또는 목적지 레지스터에 저장

-   **CPU Instruction Cycle**
    ```
    Start
    └── Fetch → Decode → [간접 여부 체크]
                         ├─ 간접: AR ← M[AR]
                         └─ 직접: 그대로 사용
    └── Execute (ALU, I/O 등)
    └── Store (필요시)
    ```
-   MRI (Memory Reference Instruction)일 경우, 직접 주소인지 간접주소인지 파악하여 실제 명령어의 주소를 가져옴
-   Operand가 있는 주소를 알아내는 것이다.

### 4. 프로그램 실행시 수행되는 서브루틴

-   사용자가 더블 클릭(입력) → 시스템 콜 호출 (`fork()`, `exec()`)
-   OS는 해당 프로그램을 HDD에서 찾고 메모리로 로드
-   PC를 실행 시작 주소(예: 1024)로 설정 → fetch-decode-execute 사이클 시작
-   실행 후, 다음 프로그램을 위한 주소값(예: 5000)으로 context 변경
